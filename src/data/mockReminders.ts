import { Reminder, ReminderType, ReminderPriority, ReminderChannel, Project } from '../types'
import { teamMembers } from './teamMembers'

// Generate mock reminders
function generateMockReminders(): Reminder[] {
  const reminders: Reminder[] = []
  const now = new Date()

  const mockData: Array<{
    type: ReminderType
    title: string
    description?: string
    hoursFromNow: number
    priority: ReminderPriority
    channels: ReminderChannel[]
    projectId?: string
    customerId?: string
    assigneeId: string
    isAutoGenerated: boolean
    triggerCondition?: string
  }> = [
    // Due today
    {
      type: 'follow-up',
      title: 'Follow up with Acme Corp on scheduling',
      description: 'Customer requested callback about install date options',
      hoursFromNow: 2,
      priority: 'high',
      channels: ['email', 'in-app'],
      projectId: 'p1',
      customerId: 'c1',
      assigneeId: teamMembers[0].id,
      isAutoGenerated: false,
    },
    {
      type: 'deadline',
      title: 'FOC deadline approaching - TechStartup',
      description: 'Project is 3 days from FOC date',
      hoursFromNow: 4,
      priority: 'urgent',
      channels: ['email', 'sms', 'in-app'],
      projectId: 'p2',
      customerId: 'c2',
      assigneeId: teamMembers[1].id,
      isAutoGenerated: true,
      triggerCondition: 'FOC date within 3 days',
    },
    {
      type: 'check-in',
      title: 'Weekly check-in - Global Retail',
      description: 'VIP customer weekly status call',
      hoursFromNow: 6,
      priority: 'normal',
      channels: ['in-app'],
      customerId: 'c3',
      assigneeId: teamMembers[0].id,
      isAutoGenerated: false,
    },
    // Due tomorrow
    {
      type: 'follow-up',
      title: 'Send install confirmation email',
      description: 'Confirm install details for scheduled date',
      hoursFromNow: 24,
      priority: 'normal',
      channels: ['email'],
      projectId: 'p3',
      customerId: 'c3',
      assigneeId: teamMembers[2].id,
      isAutoGenerated: true,
      triggerCondition: 'Install scheduled for T+2 days',
    },
    {
      type: 'escalation',
      title: 'Escalated project needs resolution',
      description: 'Project has been escalated for 5+ days',
      hoursFromNow: 28,
      priority: 'high',
      channels: ['email', 'slack', 'in-app'],
      projectId: 'p4',
      customerId: 'c4',
      assigneeId: teamMembers[0].id,
      isAutoGenerated: true,
      triggerCondition: 'Escalated project > 5 days',
    },
    // Due this week
    {
      type: 'check-in',
      title: 'Post-install satisfaction call',
      description: 'Call customer 7 days after install to check satisfaction',
      hoursFromNow: 72,
      priority: 'normal',
      channels: ['in-app'],
      projectId: 'p5',
      customerId: 'c5',
      assigneeId: teamMembers[1].id,
      isAutoGenerated: true,
      triggerCondition: 'Install completed T+7 days',
    },
    {
      type: 'custom',
      title: 'Submit permit application',
      description: 'NYC DOB permit required before install',
      hoursFromNow: 96,
      priority: 'high',
      channels: ['email', 'in-app'],
      projectId: 'p6',
      assigneeId: teamMembers[2].id,
      isAutoGenerated: false,
    },
    // Overdue
    {
      type: 'follow-up',
      title: 'Contact customer about blocker resolution',
      description: 'Waiting on customer equipment for 10 days',
      hoursFromNow: -24,
      priority: 'urgent',
      channels: ['email', 'sms', 'in-app'],
      projectId: 'p7',
      customerId: 'c7',
      assigneeId: teamMembers[0].id,
      isAutoGenerated: true,
      triggerCondition: 'Blocker unresolved > 7 days',
    },
    {
      type: 'deadline',
      title: 'SOW approval needed',
      description: 'SOW sent 14 days ago, awaiting approval',
      hoursFromNow: -48,
      priority: 'high',
      channels: ['email', 'in-app'],
      projectId: 'p8',
      customerId: 'c8',
      assigneeId: teamMembers[1].id,
      isAutoGenerated: true,
      triggerCondition: 'SOW pending > 14 days',
    },
  ]

  mockData.forEach((data, index) => {
    const dueAt = new Date(now)
    dueAt.setHours(dueAt.getHours() + data.hoursFromNow)

    const createdAt = new Date(now)
    createdAt.setDate(createdAt.getDate() - 2) // Created 2 days ago

    reminders.push({
      id: `reminder-${index + 1}`,
      type: data.type,
      title: data.title,
      description: data.description,
      dueAt: dueAt.toISOString(),
      status: data.hoursFromNow < 0 ? 'pending' : 'pending', // All pending for mock
      priority: data.priority,
      channels: data.channels,
      projectId: data.projectId,
      customerId: data.customerId,
      assigneeId: data.assigneeId,
      isAutoGenerated: data.isAutoGenerated,
      triggerCondition: data.triggerCondition,
      createdAt: createdAt.toISOString(),
      createdBy: data.isAutoGenerated ? 'system' : teamMembers[0].id,
      isRecurring: false,
    })
  })

  return reminders
}

export const mockReminders = generateMockReminders()

export function getRemindersByAssignee(assigneeId: string): Reminder[] {
  return mockReminders.filter(r => r.assigneeId === assigneeId && r.status === 'pending')
}

export function getRemindersByProject(projectId: string): Reminder[] {
  return mockReminders.filter(r => r.projectId === projectId && r.status === 'pending')
}

export function getOverdueReminders(): Reminder[] {
  const now = new Date()
  return mockReminders.filter(r =>
    r.status === 'pending' && new Date(r.dueAt) < now
  )
}

export function getUpcomingReminders(hours: number = 24): Reminder[] {
  const now = new Date()
  const cutoff = new Date(now.getTime() + hours * 60 * 60 * 1000)
  return mockReminders.filter(r => {
    const dueAt = new Date(r.dueAt)
    return r.status === 'pending' && dueAt >= now && dueAt <= cutoff
  })
}

// Auto-generate reminders based on project state
export function generateAutoReminders(projects: Project[]): Reminder[] {
  const autoReminders: Reminder[] = []
  const now = new Date()

  projects.forEach(project => {
    if (project.status === 'completed') return

    const focDate = new Date(project.focDate)
    const daysTillFOC = Math.floor((focDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))

    // FOC approaching
    if (daysTillFOC <= 3 && daysTillFOC > 0) {
      autoReminders.push({
        id: `auto-foc-${project.id}`,
        type: 'deadline',
        title: `FOC in ${daysTillFOC} day${daysTillFOC !== 1 ? 's' : ''}`,
        description: `Project FOC date is ${focDate.toLocaleDateString()}`,
        dueAt: now.toISOString(),
        status: 'pending',
        priority: 'urgent',
        channels: ['email', 'in-app'],
        projectId: project.id,
        customerId: project.customerId,
        assigneeId: project.cxAssignee || teamMembers[0].id,
        isAutoGenerated: true,
        triggerCondition: `FOC date within ${daysTillFOC} days`,
        createdAt: now.toISOString(),
        createdBy: 'system',
        isRecurring: false,
      })
    }

    // FOC overdue
    if (daysTillFOC < 0) {
      autoReminders.push({
        id: `auto-overdue-${project.id}`,
        type: 'escalation',
        title: `Project ${Math.abs(daysTillFOC)} days past FOC`,
        description: `FOC was ${focDate.toLocaleDateString()} - needs attention`,
        dueAt: now.toISOString(),
        status: 'pending',
        priority: 'urgent',
        channels: ['email', 'sms', 'in-app'],
        projectId: project.id,
        customerId: project.customerId,
        assigneeId: project.cxAssignee || teamMembers[0].id,
        isAutoGenerated: true,
        triggerCondition: 'FOC date passed',
        createdAt: now.toISOString(),
        createdBy: 'system',
        isRecurring: false,
      })
    }

    // Escalated projects
    if (project.isEscalated && project.escalatedAt) {
      const escalatedDays = Math.floor(
        (now.getTime() - new Date(project.escalatedAt).getTime()) / (1000 * 60 * 60 * 24)
      )
      if (escalatedDays >= 3) {
        autoReminders.push({
          id: `auto-escalation-${project.id}`,
          type: 'escalation',
          title: `Escalation unresolved for ${escalatedDays} days`,
          description: project.escalationReason || 'Escalated project needs attention',
          dueAt: now.toISOString(),
          status: 'pending',
          priority: 'high',
          channels: ['email', 'in-app'],
          projectId: project.id,
          customerId: project.customerId,
          assigneeId: project.cxAssignee || teamMembers[0].id,
          isAutoGenerated: true,
          triggerCondition: 'Escalated > 3 days',
          createdAt: now.toISOString(),
          createdBy: 'system',
          isRecurring: false,
        })
      }
    }

    // Stale contact
    const lastContact = new Date(project.lastCustomerContact)
    const daysSinceContact = Math.floor(
      (now.getTime() - lastContact.getTime()) / (1000 * 60 * 60 * 24)
    )
    if (daysSinceContact >= 7) {
      autoReminders.push({
        id: `auto-contact-${project.id}`,
        type: 'check-in',
        title: `No contact in ${daysSinceContact} days`,
        description: 'Customer may need a check-in call',
        dueAt: now.toISOString(),
        status: 'pending',
        priority: daysSinceContact >= 14 ? 'high' : 'normal',
        channels: ['in-app'],
        projectId: project.id,
        customerId: project.customerId,
        assigneeId: project.cxAssignee || teamMembers[0].id,
        isAutoGenerated: true,
        triggerCondition: `No contact > ${daysSinceContact} days`,
        createdAt: now.toISOString(),
        createdBy: 'system',
        isRecurring: false,
      })
    }
  })

  return autoReminders
}
